#summary This page discusses the basic concepts of BASE.

= Introduction =

BASE is an object-oriented communication middleware that has been developed to support the interaction between heterogeneous, spontaneously networked and possibly embedded devices. Its main goal is to ease the application development of distributed applications that are executed by the devices in the vicinity of a single user. In contrast to other middleware systems for pervasive computing, BASE does not rely on the concept of smart environments in which the interaction between devices is mediated by a central system. Instead, it follows a strictly peer-to-peer-based approach in which devices are free to form so-called smart peer groups. A smart peer group is typically defined by the set of devices that are within communication range of some short-range wireless networking technology.

In order to support a broad range of heterogeneous devices and applications, BASE provides a minimal core that can be flexibly extended, depending on the capabilities of the target device and the requirements of the applications. To enable this extensibility, the core can support different types of application objects and it can be equipped with various plug-ins that encapsulate communication abstractions (e.g. RMI, Publish-Subscribe), protocols (e.g. encryption, serialization) and technologies (e.g. IP, Bluetooth, IR). At runtime, the core uses the available plug-ins to dynamically compose suitable communication stacks that can be used to mediate interactions. In order to decouple the interaction pattern of the application from the interaction pattern of the communication abstraction, BASE introduces a so-called invocation object that uniformly represents an interaction (e.g. a RMI request or a Publish-Subscribe event). As a consequence, the core is agnostic to the actual communication abstraction as it only mediates invocations that are exchanged between application objects.

In addition to the mediation of invocations by means of automatically composed communication stacks, BASE also provides basic signaling mechanisms to detect communication failures as well as the availability or unavailability of devices in the vicinity. Although, the core itself is independent from the abstraction used to implement applications, in the past it has been used already to implement service-oriented applications as well as component-based applications. In the following, we outline the resulting architecture of the core and we describe the interaction between devices in more detail. 

= Architecture =

The overall architecture of BASE can be divided into three layers that are depicted in Figure 1. At the highest layer – the application layer, local and remote application objects and system services interact with each other. To do this, they rely on the functionality offered by the middleware core which is represented by the micro-broker layer. The micro-broker layer, in turn, uses the capabilities of the plug-in layer to discover remote devices and to communicate with them. In the following, we briefly walk through these layers and describe the relevant details.

http://pppc-base.googlecode.com/svn/wiki/images/architecture.png
*Figure 1: Architecture*

*Micro-broker layer:* The core of the system is formed by the so-called micro-broker. In the style of micro-kernel based operating systems, the micro-broker implements a minimal and generic middleware core. This core consists of the invocation broker, the device registry and the object registry. The invocation broker is responsible for forwarding and dispatching invocation objects or simply invocations. As indicated previously, invocations represent an interaction between application objects such as a local or remote method invocation. To decouple the application from invocation processing, the invocation broker implements different synchronization alternatives. Furthermore, the broker assigns globally unique invocation identifiers, allowing the parallel mediation. Finally, it keeps a table of invocations that have not been completed, to support the implementation of different execution semantics.
If an invocation should be dispatched to a local application object, the invocation broker retrieves the application’s so-called invocation handler from the object registry and forwards the invocation to it. When a handler is registered at the object registry, the registry associates a locally unique object identifier (OID) with the handler and stores the mapping for later retrieval. The range of OIDs is statically divided into generated and well-known OIDs. The latter ones can be used to implement bootstrap services that manage the generated OIDs. 
If an invocation targets a remote system, the invocation broker forwards it to the plug-in manager which takes care of communication. To determine the appropriate plug-ins for transmission, the manager must compute a compatible set of plug-ins. This requires knowledge about the plug-ins available on the local and the remote system. This knowledge is maintained in the device registry in the form of plug-in descriptions and it is updated as part of the device discovery process. In addition, the device registry stores a device description for each device which consists of a logical device identifier – the system id (SID) – that is independent from the utilized communication technology and a list of the well-known services registered at the corresponding device registry. Thus, application objects and services can query the device registry for local and remote objects with well-known OIDs and can contact them without further ado.

*Application layer:* At the application layer, application objects and middleware services are interacting with each other using the mediation functionality that is provided by the micro-broker layer. In order to write an application object that can receive an invocation, a programmer must implement an appropriate invocation handler that accepts invocations from the invocation broker. The invocation handler must then be registered at the object registry. Other application objects that know the OID of the invocation handler can then interact with it by creating invocations and passing them to the invocation broker. BASE encompasses tools to create stubs and skeletons from application interfaces to ease this task. In order to distribute the OIDs

*Plug-in layer:* The two functions provided by the plug-in layer are device discovery and remote communication. The implementation of these functions is not only dependent on the targeted communication technology, but also on the targeted protocols and abstractions. Thereby, it is important to note that the communication technologies are usually determined by the hardware capabilities of a device. The suitability of a communication abstraction and protocol, however, is usually dependent on the interaction patterns of the application. It is noteworthy that it is often possible to implement one abstraction using another. For example, one may implement event-based communication using remote method calls. Similarly, it is possible to use a single protocol with a fixed set of data units and a homogeneous data representation. However, the utilization of a one-size-fits-all solution may lead to considerable performance penalties. Such penalties are especially problematic when applications are executed on resource-poor devices. 
To support the efficient implementation of a broad range of applications, the BASE plug-in layer encapsulates these functionalities in plug-ins so that the middleware can be configured for a particular device with a set of applications. In order to configure BASE, a developer registers the desired plug-ins at the plug-in manager. After the registration, the plug-in manager takes care of automatically composing communication stacks from different plug-ins. To control this composition process, an application developer can attach a collection of non-functional parameters to an invocation object. This collection is then interpreted during the composition. In the following, we first introduce the different types of plug-ins that are supported by BASE before we discuss how remote communication and device discovery are supported.

= Plug-ins =

In order to support the runtime composition of communication stacks, BASE separates the functionalities of a stack into blocks and it defines interfaces between them. In order to do this, it divides the functionality of the communication stack into communication technologies, protocols and abstractions as depicted in Figure 2.
Underneath the middleware, the operating system manages the available network interfaces and provides an application programming interface which may be specific for a certain technology. To abstract from the differences, it is necessary to specify a common interface. Due to the fact that discovery plug-ins need to distribute availability information among all available devices and due to the fact that many communication abstractions need to transmit larger amounts of data reliably, BASE relies on a socket-style API that supports unreliable packet-oriented communication with local broadcast semantic for discovery and reliable connection-oriented communication for the transmission of invocations. 

http://pppc-base.googlecode.com/svn/wiki/images/pluginlayers.png
*Figure 2: Plug-in Layers*

Given that the lowest layer supports connection-oriented communication, the protocols above need to operate on the byte-streams of the connection. Since BASE is built on top of an object-oriented programming language, it is possible classify the protocols in protocols that solely modify the byte-stream and protocols that (de-) serialize objects. A simple example for a functionality that falls into the first class is data compression that performs run-length encoding on chunks of input data. A more complex example is a plug-in for secure communication that uses asymmetric encryption to exchange a symmetric session key. In contrast to the first example, the second introduces additional data transfers, e.g. an initial hand-shake to securely distribute a session key. On top of protocols that operate solely on the byte stream, we may have additional protocols that generate byte-streams from objects and vice versa. 

Obviously, it is possible to stack the protocols that solely use byte-streams as input and output in an arbitrary order. However, due to the different input and output data types of protocols that (de-) serialize objects, there can only be one protocol per stack and it needs to reside above the protocols that operate on byte-streams. Above the communication technology and protocols, the communication abstraction determines how an invocation should be distributed. Thereby, it is important to note that it is inappropriate to associate the abstraction with a particular connection for an invocation. The reason for this is twofold. First, in order to enable the implementation of a failure resilient distribution of invocations in spite of temporary disconnections, it may be necessary to reestablish a connection. Given that different communication technologies usually exhibit different transmission ranges, it may even be necessary to recompose a complete stack of protocols and technologies at the lower layers before attempting to reconnect. Secondly, more complex communication abstractions may not rely on a simple one-to-one connection but they may distribute an invocation to a number of devices. As an example consider that an invocation that represents a publication in a publish/subscribe approach needs to be distributed to all available subscribers. As a consequence, it is necessary to enable developers of communication abstractions to manage the connection establishment at this layer. So in contrast to protocols – which are passively stacked on top of a connection from a particular technology – abstractions actively request the initialization of an underlying stack.

In summary, this results in four different plug-in layers shown in Figure 2. At the lowest level, transceivers provide unreliable packet-oriented and connection-oriented communication. Above the transceiver, an arbitrary number of modifiers implement protocols that modify the byte-streams transmitted over the connection. Above these protocols, a serializer is responsible for the (de-) serialization of objects. Finally, at the highest layer, the semantic requests connections that are created by stacking transceivers, modifiers and serializers on top of each other. In the next section, we take a closer look at this interaction. 

= Communication =

The primary goal of the plug-in architecture is to increase the flexibility by enabling the on-demand composition of plug-ins according to the needs of the application. To allow varying degrees of control and automation, invocations can be equipped with a set of non-functional parameters that model requirements on the communication stack. To avoid unnecessary restrictions on the flexibility of compositions, the internal structure of the parameters corresponds to a list of requirements that is ordered according to the targeted layer of the stack. This means that the head of the list specifies requirements on the semantic whereas the tail usually specifies requirements on the transceiver. The parameter list ensures that requirements are added according to the restrictions setup by the layers. For example, it ensures that requirements on modifiers are not added above the serializer. In addition, the list structure also enables the developer to refrain from specifying requirements on a certain layer in cases where the implementation of the layer is not relevant. However, as a minimum, the developer must specify the requirements on the semantic since they change the meaning of the invocation.

The individual requirements can be specified at various levels of details ranging from explicit requests for a particular type of plug-in to abstract requests for an implementation-specific characteristic. As a simple example for such a characteristic consider the bit-length of the session key for an encryption plug-in. Due to the fact that the plug-in manager is generic, it cannot understand the intrinsic meanings of all plug-in implementations. Furthermore, since the correctness of a plug-in may rely on the presence of plug-ins with certain characteristics at lower layers, it is necessary to enable plug-ins to refine the requirements on plug-ins at lower layers. For example, a semantic may require the presence of a serializer to transmit objects even though this has not been specified directly by the application.

In order to deal with these two issues in an efficient manner, BASE separates the composition into a negotiation phase during which a set of plug-ins is computed and a connection phase during which a previously negotiated set of plug-ins is connected. In order to enable plug-ins to refine the requirements on lower layers, the negotiation phase must be performed top-down as depicted on the right side of Figure 3. The connection phase, on the contrary, should be performed in a bottom-up fashion as shown in Figure 4. As explained later on, the bottom up connection simplifies the interfaces of plug-ins by enabling the reuse of methods on the receiver and the sender side. Furthermore, it avoids the introduction of a lifecycle during the connection phase since plug-ins can rely on the fact that lower layers are fully initialized. In the following, we describe the details of these phases. For simplicity, we assume that the invocation represents a remote method invocation that returns a result. However, other communication abstractions can be implemented analogously.

http://pppc-base.googlecode.com/svn/wiki/images/pluginnegotiation.png
*Figure 3: Plug-in Negotiation*

When an invocation that represents the request must be transmitted to another system, the micro-broker forwards it to the plug-in manger as shown in step (1) of Figure 3. As explained, the requirements on the communication stack are specified using a list of parameters that is attached to the invocation. After the plug-in manager has received the invocation, it computes the candidate set of semantic plug-ins (2). If the requirements attached to the invocation are explicitly specifying a particular plug-in, the plug-in manager selects the corresponding plug-in as target. If the requirements are solely specifying implementation-specific characteristics, the plug-in manager selects all semantic plug-ins as targets. The plug-in manager asks each target plug-in whether it can fulfill the requirements specified by the parameter list (3). If the call fails, the next plug-in is selected. Otherwise, the plug-in manager aborts the process and forwards the invocation to the plug-in that acknowledged the requirements (4). If no semantic plug-in can be found, the plug-in manager signals this to the invocation broker which informs the application. After the semantic plug-in has received the invocation, it will transmit it to the remote system and after receiving the result, it forwards an invocation that represents the result to the plug-in manager (5). The plug-in manager in turn will forward the invocation to the broker (6) which will deliver the result, e.g. by releasing a blocked application thread. 

= Negotiation =

To transmit the invocation to the remote system, the semantic plug-in can establish a connection that is composed from plug-ins at lower levels. To do this, it must first negotiate a stack. This negotiation is shown on the right side of Figure 3. To start the negotiation (7), it passes three references to plug-in manager. The references encompass the system identifier of the target system, the configuration object and a reference to the requesting semantic plug-in. After receiving the negotiation request, the plug-in manager will compute a set of plug-ins that is available both, the local and the target system. To do this, it queries the device registry for the plug-in descriptions of the remote device and it intersects the set with the plug-in descriptions of local plug-ins (8). Thereafter, the plug-in manager validates that the requesting semantic is also available on the remote device. If this is not the case, the negotiation fails immediately. Otherwise, the manager creates a session object for the request.

Similar to the requirements contained in the parameter list, session objects can be linked together as a list that represents a particular stack configuration. However, in contrast to the parameter list, a session object does not store abstract requirements but it stores a concrete plug-in identifier. Consequently, a list of session objects can be used to describe a stack for a particular system. In addition to solely storing the identifier of the plug-in, the session objects can also store a set of plug-in specific parameters that are required to establish a connection. This set of parameters is divided into local parameters that are required on the client-side and remote parameters that are needed on the server-side. A simple example of such a parameter is the endpoint information of a transceiver, e.g. IP address and port number of the server in the case of a TCP/IP-based transceiver. As explained later on, the session object is automatically transferred to the remote system and it is passed to all plug-ins during connection initialization. This ensures that each plug-in has all necessary information. 

Once the session object has been created, the negotiation continues below the semantic layer. Using the list of requirements received from the semantic plug-in, the plug-in manager determines whether it is necessary to add a serializer to the stack. If a serializer is required, the plug-in manager will use the set of plug-ins that is available on both systems to determine target serializers. Similar to the selection of semantic plug-ins, the plug-in manager simply prunes the list in cases where a particular serializer is required. Thereafter, it goes through the list of target serializers and asks them whether they fulfill the requirements (9). While doing this, the plug-in manager does not simply pass the requirements to the serializer. Instead, it first creates a new session object with the identifier of the serializer and it copies the configuration object. Thereafter, it passes the new session object, the copy of the configuration object as well as the plug-in description of the same plug-in on the remote device to the target plug-in. The serializer plug-in can use the plug-in description to determine whether it can communicate with the remote plug-in and it may store relevant parameters in the session object. Furthermore, as indicated previously, it may refine the requirements specified in the configuration object in cases where it depends on certain plug-ins at lower layers. If the serializer responds positive to the negotiation request, the plug-in manager stores the session object and the negotiation continues with the refined requirements at a lower layer. If it responds negative, the negotiation continues with the next serializer from the target set using the original requirements and a new session object. Again, if a serializer is required but no serializer can fulfill the requirements, the complete negotiation fails.

Once a serializer has been determined successfully, the negation continues. Depending on the requirements, it may continue with a modifier or a transceiver. If a modifier is required, the procedure of determining an appropriate serializer is simply replicated using modifiers. This means that a new session object is created, the requirements that have been refined by the serializer are copied and they are passed to the set of target modifiers (10). If all modifiers have been configured successfully, the negotiation continues with the transceivers (11). If the configuration fails at some point, the last successfully negotiated plug-in is invalidated. To do this, the session object is simply removed from the list and the negotiation continues using the previously computed target plug-in set and the original set of requirements.

As a consequence, the composition algorithm essentially resembles backtracking where the latest decision is reverted in cases where it has been proven to fail. Backtracking ensures that all possible compositions are systematically tested. However, at the same time it can also lead to an exponential runtime overhead in cases where the composition with multiple options on higher layers fails frequently at the lower layers. Yet, such a thrashing can only occur if the communicating devices are equipped with similar plug-ins at higher layers that require certain lower layer plug-ins which are not able to communicate. For a small number of plug-ins, this might happen in cases where the transceivers are not able to connect. However, for a large number of plug-ins such a situation rather indicates an improperly configured device. 
The negotiation phase ends when the transceiver plug-in has been selected which means that all requirements are fulfilled. The result of the negotiation is a linked list of session objects that has been created and stored for every negotiation request at a plug-in, i.e. (7’), (9’), (10’), (11’). This list stores the plug-in identifiers and the parameters needed during connection establishment for all layers below the semantic. By returning the top-most session object as the result of step (7), the semantic plug-in can finalize the composition process by adding parameters for its own layer. 

= Connection = 

After the negotiation, the semantic can request the connection establishment using the composition represented by the session objects. To do this, it simply passes the session objects to the plug-in manager as depicted in step (1) on the left side of Figure 4. The plug-in manager uses the list of session objects to connect the plug-ins in bottom-up fashion. It first calls the transceiver with the corresponding session object to establish the connection at the lowest layer (2). If the establishment succeeds, the transceiver returns a so-called connector that holds references to the input and output streams of the connection. The connector is similar to a socket and besides providing the references to the streams, it also provides operations to close the connection. 

When the transceiver on the client-side contacts an end-point, it uniquely identifies a transceiver on the server-side, e.g. via IP address and port. As a consequence, the server-side knows the plug-in at the lowest layer. Since there may be arbitrary plug-ins stacked on top of this layer, it is necessary to transmit the composition. To do this, the plug-in manager on the client-side transmits the session objects together with the remote parameters (3) before continuing at higher layers. This enables the server-side to perform the connection establishment in parallel and it ensures that each plug-in can immediately contact its counterpart using the connector of the lower layers.

Once the session objects have been transmitted, the plug-in manager on the client-side initializes the remaining plug-ins. When a plug-in must be added the manager requests a connector from the plug-in. To do this, it passes the corresponding session object together with the connector of the transceiver (4). If the request succeeds, the modifier returns a new connector. This connector typically wraps the connector of the transceiver and provides new input and output streams using the underlying streams. The connector returned by the modifier may then be used to initialize the serializer. Analogous to the initialization of a modifier, the plug-in manager simply requests a new connector by passing the session object together with the connector from the last plug-in that has been initialized (5). Once the connector is returned, the manager passes the connector to the semantic plug-in as a response to the initial request (1). 

http://pppc-base.googlecode.com/svn/wiki/images/pluginconnection.png
*Figure 4: Plug-in Connection*

At the server-side this process is mirrored. However, since the server is passive, the connection establishment is started in response to the connection attempt of the client. Once the client-side has established a connection at the transceiver layer, the transceiver plug-in at the server-side signals the new connection by passing a connector to the plug-in manager as depicted in step (1’) on the right side of Figure 5. Using this connector, the plug-in manager receives the session objects from the client (2’). Thereafter, it initializes the modifier (3’) and serializer (4’) plug-in. As a last step, the plug-in manager forwards the connector to the semantic plug-in (5’) which takes care of the actual data reception and interpretation. If this process fails at any point in time on the client- or on the server-side, the plug-ins may signal this through an exception and the plug-in manager takes care of closing the opened connection. The premature disconnection eventually causes a failure on the opposite side as well and the other plug-in manager can also perform the cleanup.

= Discovery =

In order to signal the availability and unavailability of devices, the BASE device registry relies on discovery plug-ins to detect devices. To abstract from devices in a uniform way, the BASE core introduces a so-called device description. As indicated previously, the device description consists of a logical device identifier – the so-called system id (SID) – which uniquely identifies a device in a technology independent way. Furthermore, the description also contains the object identifiers (OID) of well-known objects that are registered at the object registry. By distributing this description in a proactive manner, a discovery plug-ins enables devices to reason about the available devices and their capabilities.

However, as explained in the previous subsection, to enable the on-demand composition of communication stacks it is also necessary to distribute the plug-in descriptions to enable devices to reason about plug-in stack compatibility. Yet, this information can also be distributed on demand by the discovery plug-ins which can reduce the amount of data that is distributed proactively at the cost of a higher latency during the first attempt to contact a remote system.

As transceiver plug-ins are required to provide two types of interfaces - a connection-oriented interface as well as a packet-oriented interface with broadcast semantics – discovery plug-ins do not have to interface with the underlying communication technologies. Instead, they can simply use the packet-oriented transceiver interfaces to distribute the device and plug-in descriptions. Thereby, the plug-in descriptions of the transceiver plug-ins are used to signal single-hop connectivity. As a consequence, a discovery plug-in must distribute the transceiver plug-in descriptions only via the appropriate transceiver plug-in. This ensures that the plug-in composition does not fail repeatedly due to invalid connectivity information.

In order to make the device and plug-in descriptions available to the remaining parts of the system, a discovery plug-in simply registers them using the plug-in manager which will store the information in the device registry. The device registry will then ensure that new additions and removals are signaled to interested application objects that have registered for receiving this information.

= Device Support =

As indicated previously, the core of the BASE middleware and a number of plug-ins are freely available as open source. The available software is implemented in Java. The core of the middleware is written against the Micro Edition of the Java 2 Platform. The minimum requirement for running the core on a device is the availability of a Connected Limited Device Configuration (CLDC) for the device. 

http://pppc-base.googlecode.com/svn/wiki/images/implementation.png
*Figure 5: Device Support*

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages