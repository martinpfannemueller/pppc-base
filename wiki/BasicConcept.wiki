#summary This page discusses the basic concepts of BASE.

= Introduction =

BASE is an object-oriented communication middleware that has been developed to support the interaction between heterogeneous, spontaneously networked and possibly embedded devices. Its main goal is to ease the application development of distributed applications that are executed by the devices in the vicinity of a single user. In contrast to other middleware systems for pervasive computing, BASE does not rely on the concept of smart environments in which the interaction between devices is mediated by a central system. Instead, it follows a strictly peer-to-peer-based approach in which devices are free to form so-called smart peer groups. A smart peer group is typically defined by the set of devices that are within communication range of some short-range wireless networking technology.

In order to support a broad range of heterogeneous devices and applications, BASE provides a minimal core that can be flexibly extended, depending on the capabilities of the target device and the requirements of the applications. To enable this extensibility, the core can support different types of application objects and it can be equipped with various plug-ins that encapsulate communication abstractions (e.g. RMI, Publish-Subscribe), protocols (e.g. encryption, serialization) and technologies (e.g. IP, Bluetooth, IR). At runtime, the core uses the available plug-ins to dynamically compose suitable communication stacks that can be used to mediate interactions. In order to decouple the interaction pattern of the application from the interaction pattern of the communication abstraction, BASE introduces a so-called invocation object that uniformly represents an interaction (e.g. a RMI request or a Publish-Subscribe event). As a consequence, the core is agnostic to the actual communication abstraction as it only mediates invocations that are exchanged between application objects.

In addition to the mediation of invocations by means of automatically composed communication stacks, BASE also provides basic signaling mechanisms to detect communication failures as well as the availability or unavailability of devices in the vicinity. Although, the core itself is independent from the abstraction used to implement applications, in the past it has been used already to implement service-oriented applications as well as component-based applications. In the following, we outline the resulting architecture of the core and we describe the interaction between devices in more detail. 

= Architecture =

The overall architecture of BASE can be divided into three layers that are depicted in Figure 1. At the highest layer – the application layer, local and remote application objects and system services interact with each other. To do this, they rely on the functionality offered by the middleware core which is represented by the micro-broker layer. The micro-broker layer, in turn, uses the capabilities of the plug-in layer to discover remote devices and to communicate with them. In the following, we briefly walk through these layers and describe the relevant details.

*Micro-broker layer:* The core of the system is formed by the so-called micro-broker. In the style of micro-kernel based operating systems, the micro-broker implements a minimal and generic middleware core. This core consists of the invocation broker, the device registry and the object registry. The invocation broker is responsible for forwarding and dispatching invocation objects or simply invocations. As indicated previously, invocations represent an interaction between application objects such as a local or remote method invocation. To decouple the application from invocation processing, the invocation broker implements different synchronization alternatives. Furthermore, the broker assigns globally unique invocation identifiers, allowing the parallel mediation. Finally, it keeps a table of invocations that have not been completed, to support the implementation of different execution semantics.
If an invocation should be dispatched to a local application object, the invocation broker retrieves the application’s so-called invocation handler from the object registry and forwards the invocation to it. When a handler is registered at the object registry, the registry associates a locally unique object identifier (OID) with the handler and stores the mapping for later retrieval. The range of OIDs is statically divided into generated and well-known OIDs. The latter ones can be used to implement bootstrap services that manage the generated OIDs. 
If an invocation targets a remote system, the invocation broker forwards it to the plug-in manager which takes care of communication. To determine the appropriate plug-ins for transmission, the manager must compute a compatible set of plug-ins. This requires knowledge about the plug-ins available on the local and the remote system. This knowledge is maintained in the device registry in the form of plug-in descriptions and it is updated as part of the device discovery process. In addition, the device registry stores a device description for each device which consists of a logical device identifier – the system id (SID) – that is independent from the utilized communication technology and a list of the well-known services registered at the corresponding device registry. Thus, application objects and services can query the device registry for local and remote objects with well-known OIDs and can contact them without further ado.
*Application layer:* At the application layer, application objects and middleware services are interacting with each other using the mediation functionality that is provided by the micro-broker layer. In order to write an application object that can receive an invocation, a programmer must implement an appropriate invocation handler that accepts invocations from the invocation broker. The invocation handler must then be registered at the object registry. Other application objects that know the OID of the invocation handler can then interact with it by creating invocations and passing them to the invocation broker. BASE encompasses tools to create stubs and skeletons from application interfaces to ease this task. In order to distribute the OIDs
*Plug-in layer:* The two functions provided by the plug-in layer are device discovery and remote communication. The implementation of these functions is not only dependent on the targeted communication technology, but also on the targeted protocols and abstractions. Thereby, it is important to note that the communication technologies are usually determined by the hardware capabilities of a device. The suitability of a communication abstraction and protocol, however, is usually dependent on the interaction patterns of the application. It is noteworthy that it is often possible to implement one abstraction using another. For example, one may implement event-based communication using remote method calls. Similarly, it is possible to use a single protocol with a fixed set of data units and a homogeneous data representation. However, the utilization of a one-size-fits-all solution may lead to considerable performance penalties. Such penalties are especially problematic when applications are executed on resource-poor devices. 
To support the efficient implementation of a broad range of applications, the BASE plug-in layer encapsulates these functionalities in plug-ins so that the middleware can be configured for a particular device with a set of applications. In order to configure BASE, a developer registers the desired plug-ins at the plug-in manager. After the registration, the plug-in manager takes care of automatically composing communication stacks from different plug-ins. To control this composition process, an application developer can attach a collection of non-functional parameters to an invocation object. This collection is then interpreted during the composition. In the following, we first introduce the different types of plug-ins that are supported by BASE before we discuss how remote communication and device discovery are supported.



= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages