#summary This page discusses the basic concepts of BASE.

= Introduction =

BASE is an object-oriented communication middleware that has been developed to support the interaction between heterogeneous, spontaneously networked and possibly embedded devices. Its main goal is to ease the application development of distributed applications that are executed by the devices in the vicinity of a single user. In contrast to other middleware systems for pervasive computing, BASE does not rely on the concept of smart environments in which the interaction between devices is mediated by a central system. Instead, it follows a strictly peer-to-peer-based approach in which devices are free to form so-called smart peer groups. A smart peer group is typically defined by the set of devices that are within communication range of some short-range wireless networking technology.

In order to support a broad range of heterogeneous devices and applications, BASE provides a minimal core that can be flexibly extended, depending on the capabilities of the target device and the requirements of the applications. To enable this extensibility, the core can support different types of application objects and it can be equipped with various plug-ins that encapsulate communication abstractions (e.g. RMI, Publish-Subscribe), protocols (e.g. encryption, serialization) and technologies (e.g. IP, Bluetooth, IR). At runtime, the core uses the available plug-ins to dynamically compose suitable communication stacks that can be used to mediate interactions. In order to decouple the interaction pattern of the application from the interaction pattern of the communication abstraction, BASE introduces a so-called invocation object that uniformly represents an interaction (e.g. a RMI request or a Publish-Subscribe event). As a consequence, the core is agnostic to the actual communication abstraction as it only mediates invocations that are exchanged between application objects.

In addition to the mediation of invocations by means of automatically composed communication stacks, BASE also provides basic signaling mechanisms to detect communication failures as well as the availability or unavailability of devices in the vicinity. Although, the core itself is independent from the abstraction used to implement applications, in the past it has been used already to implement service-oriented applications as well as component-based applications. In the following, we outline the resulting architecture of the core and we describe the interaction between devices in more detail. 

= Architecture =

The overall architecture of BASE can be divided into three layers that are depicted in Figure 1. At the highest layer – the application layer, local and remote application objects and system services interact with each other. To do this, they rely on the functionality offered by the middleware core which is represented by the micro-broker layer. The micro-broker layer, in turn, uses the capabilities of the plug-in layer to discover remote devices and to communicate with them. In the following, we briefly walk through these layers and describe the relevant details.

*Micro-broker layer:* The core of the system is formed by the so-called micro-broker. In the style of micro-kernel based operating systems, the micro-broker implements a minimal and generic middleware core. This core consists of the invocation broker, the device registry and the object registry. The invocation broker is responsible for forwarding and dispatching invocation objects or simply invocations. As indicated previously, invocations represent an interaction between application objects such as a local or remote method invocation. To decouple the application from invocation processing, the invocation broker implements different synchronization alternatives. Furthermore, the broker assigns globally unique invocation identifiers, allowing the parallel mediation. Finally, it keeps a table of invocations that have not been completed, to support the implementation of different execution semantics.
If an invocation should be dispatched to a local application object, the invocation broker retrieves the application’s so-called invocation handler from the object registry and forwards the invocation to it. When a handler is registered at the object registry, the registry associates a locally unique object identifier (OID) with the handler and stores the mapping for later retrieval. The range of OIDs is statically divided into generated and well-known OIDs. The latter ones can be used to implement bootstrap services that manage the generated OIDs. 
If an invocation targets a remote system, the invocation broker forwards it to the plug-in manager which takes care of communication. To determine the appropriate plug-ins for transmission, the manager must compute a compatible set of plug-ins. This requires knowledge about the plug-ins available on the local and the remote system. This knowledge is maintained in the device registry in the form of plug-in descriptions and it is updated as part of the device discovery process. In addition, the device registry stores a device description for each device which consists of a logical device identifier – the system id (SID) – that is independent from the utilized communication technology and a list of the well-known services registered at the corresponding device registry. Thus, application objects and services can query the device registry for local and remote objects with well-known OIDs and can contact them without further ado.

*Application layer:* At the application layer, application objects and middleware services are interacting with each other using the mediation functionality that is provided by the micro-broker layer. In order to write an application object that can receive an invocation, a programmer must implement an appropriate invocation handler that accepts invocations from the invocation broker. The invocation handler must then be registered at the object registry. Other application objects that know the OID of the invocation handler can then interact with it by creating invocations and passing them to the invocation broker. BASE encompasses tools to create stubs and skeletons from application interfaces to ease this task. In order to distribute the OIDs

*Plug-in layer:* The two functions provided by the plug-in layer are device discovery and remote communication. The implementation of these functions is not only dependent on the targeted communication technology, but also on the targeted protocols and abstractions. Thereby, it is important to note that the communication technologies are usually determined by the hardware capabilities of a device. The suitability of a communication abstraction and protocol, however, is usually dependent on the interaction patterns of the application. It is noteworthy that it is often possible to implement one abstraction using another. For example, one may implement event-based communication using remote method calls. Similarly, it is possible to use a single protocol with a fixed set of data units and a homogeneous data representation. However, the utilization of a one-size-fits-all solution may lead to considerable performance penalties. Such penalties are especially problematic when applications are executed on resource-poor devices. 
To support the efficient implementation of a broad range of applications, the BASE plug-in layer encapsulates these functionalities in plug-ins so that the middleware can be configured for a particular device with a set of applications. In order to configure BASE, a developer registers the desired plug-ins at the plug-in manager. After the registration, the plug-in manager takes care of automatically composing communication stacks from different plug-ins. To control this composition process, an application developer can attach a collection of non-functional parameters to an invocation object. This collection is then interpreted during the composition. In the following, we first introduce the different types of plug-ins that are supported by BASE before we discuss how remote communication and device discovery are supported.

= Plug-ins =

In order to support the runtime composition of communication stacks, BASE separates the functionalities of a stack into blocks and it defines interfaces between them. In order to do this, it divides the functionality of the communication stack into communication technologies, protocols and abstractions as depicted in Figure 2.
Underneath the middleware, the operating system manages the available network interfaces and provides an application programming interface which may be specific for a certain technology. To abstract from the differences, it is necessary to specify a common interface. Due to the fact that discovery plug-ins need to distribute availability information among all available devices and due to the fact that many communication abstractions need to transmit larger amounts of data reliably, BASE relies on a socket-style API that supports unreliable packet-oriented communication with local broadcast semantic for discovery and reliable connection-oriented communication for the transmission of invocations. 

Given that the lowest layer supports connection-oriented communication, the protocols above need to operate on the byte-streams of the connection. Since BASE is built on top of an object-oriented programming language, it is possible classify the protocols in protocols that solely modify the byte-stream and protocols that (de-) serialize objects. A simple example for a functionality that falls into the first class is data compression that performs run-length encoding on chunks of input data. A more complex example is a plug-in for secure communication that uses asymmetric encryption to exchange a symmetric session key. In contrast to the first example, the second introduces additional data transfers, e.g. an initial hand-shake to securely distribute a session key. On top of protocols that operate solely on the byte stream, we may have additional protocols that generate byte-streams from objects and vice versa. 

Obviously, it is possible to stack the protocols that solely use byte-streams as input and output in an arbitrary order. However, due to the different input and output data types of protocols that (de-) serialize objects, there can only be one protocol per stack and it needs to reside above the protocols that operate on byte-streams. Above the communication technology and protocols, the communication abstraction determines how an invocation should be distributed. Thereby, it is important to note that it is inappropriate to associate the abstraction with a particular connection for an invocation. The reason for this is twofold. First, in order to enable the implementation of a failure resilient distribution of invocations in spite of temporary disconnections, it may be necessary to reestablish a connection. Given that different communication technologies usually exhibit different transmission ranges, it may even be necessary to recompose a complete stack of protocols and technologies at the lower layers before attempting to reconnect. Secondly, more complex communication abstractions may not rely on a simple one-to-one connection but they may distribute an invocation to a number of devices. As an example consider that an invocation that represents a publication in a publish/subscribe approach needs to be distributed to all available subscribers. As a consequence, it is necessary to enable developers of communication abstractions to manage the connection establishment at this layer. So in contrast to protocols – which are passively stacked on top of a connection from a particular technology – abstractions actively request the initialization of an underlying stack.

In summary, this results in four different plug-in layers shown in Figure 2. At the lowest level, transceivers provide unreliable packet-oriented and connection-oriented communication. Above the transceiver, an arbitrary number of modifiers implement protocols that modify the byte-streams transmitted over the connection. Above these protocols, a serializer is responsible for the (de-) serialization of objects. Finally, at the highest layer, the semantic requests connections that are created by stacking transceivers, modifiers and serializers on top of each other. In the next section, we take a closer look at this interaction. 

= Communication =

The primary goal of the plug-in architecture is to increase the flexibility by enabling the on-demand composition of plug-ins according to the needs of the application. To allow varying degrees of control and automation, invocations can be equipped with a set of non-functional parameters that model requirements on the communication stack. To avoid unnecessary restrictions on the flexibility of compositions, the internal structure of the parameters corresponds to a list of requirements that is ordered according to the targeted layer of the stack. This means that the head of the list specifies requirements on the semantic whereas the tail usually specifies requirements on the transceiver. The parameter list ensures that requirements are added according to the restrictions setup by the layers. For example, it ensures that requirements on modifiers are not added above the serializer. In addition, the list structure also enables the developer to refrain from specifying requirements on a certain layer in cases where the implementation of the layer is not relevant. However, as a minimum, the developer must specify the requirements on the semantic since they change the meaning of the invocation.

The individual requirements can be specified at various levels of details ranging from explicit requests for a particular type of plug-in to abstract requests for an implementation-specific characteristic. As a simple example for such a characteristic consider the bit-length of the session key for an encryption plug-in. Due to the fact that the plug-in manager is generic, it cannot understand the intrinsic meanings of all plug-in implementations. Furthermore, since the correctness of a plug-in may rely on the presence of plug-ins with certain characteristics at lower layers, it is necessary to enable plug-ins to refine the requirements on plug-ins at lower layers. For example, a semantic may require the presence of a serializer to transmit objects even though this has not been specified directly by the application.

In order to deal with these two issues in an efficient manner, BASE separates the composition into a negotiation phase during which a set of plug-ins is computed and a connection phase during which a previously negotiated set of plug-ins is connected. In order to enable plug-ins to refine the requirements on lower layers, the negotiation phase must be performed top-down as depicted on the right side of Figure 3. The connection phase, on the contrary, should be performed in a bottom-up fashion as shown in Figure 4. As explained later on, the bottom up connection simplifies the interfaces of plug-ins by enabling the reuse of methods on the receiver and the sender side. Furthermore, it avoids the introduction of a lifecycle during the connection phase since plug-ins can rely on the fact that lower layers are fully initialized. In the following, we describe the details of these phases. For simplicity, we assume that the invocation represents a remote method invocation that returns a result. However, other communication abstractions can be implemented analogously.

When an invocation that represents the request must be transmitted to another system, the micro-broker forwards it to the plug-in manger as shown in step (1) of Figure 3. As explained, the requirements on the communication stack are specified using a list of parameters that is attached to the invocation. After the plug-in manager has received the invocation, it computes the candidate set of semantic plug-ins (2). If the requirements attached to the invocation are explicitly specifying a particular plug-in, the plug-in manager selects the corresponding plug-in as target. If the requirements are solely specifying implementation-specific characteristics, the plug-in manager selects all semantic plug-ins as targets. The plug-in manager asks each target plug-in whether it can fulfill the requirements specified by the parameter list (3). If the call fails, the next plug-in is selected. Otherwise, the plug-in manager aborts the process and forwards the invocation to the plug-in that acknowledged the requirements (4). If no semantic plug-in can be found, the plug-in manager signals this to the invocation broker which informs the application. After the semantic plug-in has received the invocation, it will transmit it to the remote system and after receiving the result, it forwards an invocation that represents the result to the plug-in manager (5). The plug-in manager in turn will forward the invocation to the broker (6) which will deliver the result, e.g. by releasing a blocked application thread. 

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages