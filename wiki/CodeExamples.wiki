#summary A brief description of existing code examples.

= Introduction =

The *base-samples/base-tutorials* projects contain a number of simple examples. Most examples are intended to be launched multiple times so that there are several processes of BASE that represent several devices. In order for this to work, it is not possible to use the broadcast-based IP plugins since the OS will assign the associated port exclusively to one process. Although, newer versions of Java support a socket option for sharing a port, this option is not available on most smaller devices. As a consequence, it makes sense to use the multicast-based plugins for testing.

= Rmi =

The rmi tutorial is probably the simplest tutorial. It demonstrates the development of a simple service that can be accessed via a client thread. The interface of the service is defined in IRmi. Using the Eclipse Plugin, it is possible to automatically generate the necessary stubs (!RmiProxy, !RmiSkeleton). The implementation of the service inherits from the default Service class of the BASE service abstraction and it implements the interface. The main class simply starts the invocation broker and installs some plugins. In order for RMI to work, it is neccessary to have at least one semantic plugin for RMI as well as a serializer and a transceiver. Note that the tutorial installs several semantic plugins in order to perform asynchronous calls more efficiently. Furthermore, it is neccessary to have a discovery plugin that takes care of detecting remote devices. After the installation, the main class continues to register the service at the registry. Thereby, the service must specify the appropriate skeleton and it can define a name, supported types as well as other properties that are searchable. After registering the service, the main method starts a client thread. This thread will first sleep for some time and thereafter, it periodically queries the local service registry for remote services that export the IRmi interface. When it detects a service, it performs a couple of method calls. Thereby, it uses asynchronous, synchronous and deferred synchronous calls that are offered by the generated proxy. Finally, after some time, the program terminates. 

= Security =

The security tutorial is a copy of the RMI tutorial that demonstrates the features of the security extensions of BASE. The main difference is the initialization of the clients with certificates and additional plug-ins. Furthermore, the service uses a generated !SecureRmiSkeleton which allows it to validate the source of a request. The client uses a !SecureRmiProxy to initate request that can be validated. Both can be generated using the 3PC Eclipse plugins.

= Stream =

The stream example is structurally similar to the rmi tutorial. The main difference results from the fact that the service offers a streamig interface. For this to work, it is necessary to have a streaming plugin installed. Furthermore, the service must implement the streaming marker interface. Thereafter, the code generator will automatically provide adequate code to open a stream to the connector. Running multiple instances of this code will result in periodic remote transmissions via streams. Streams are in general useful to transmit large amounts of data that do not fit directly into memory. When performing a remote method invocation, you should always consider that the whole object graph needs to fit into the memory of the receiver. This is normally the case for objects resulting from program logic. However, if files ought to be transmitted, it is often easier to use streams to copy the file contents from system to system.

= Serial =

The serial example demonstrates how to use user-defined classes within interfaces. Since object serialization is not supported by CLDC JVMs, it needs to be implemented at the application level. BASE provides a generic mechanism for that. It is very similar to the standard Java serialization. The main difference is that you must write the "readObject" and "writeObject" methods by hand. In order to make an object serializable, it must implement the serializable interface (with the previously mentioned methods). Furthermore, since CDC and CLDC JVMs have only limited reflective capabilities, a serializable object must implement a public default constructure (i.e. one that has no arguments). This constructor will be used by BASE to create a object before it will call the readObject method. Usually, the read and write methods simply need to read/write the fields defined by the class in the same sequence using the input and output streams passed to the method. The resulting object graph is automatically traversed by the streams upon serialization. Besides from serializable classes, the default serializer can also handle Vectors, Hashtables, Stacks and one-dimensional arrays with primitive types or the object type as well as the primitive types and their wrapper classes. Other types must be serializable. Note that serialization problems are sometimes hard to debug since they will look like a non-functioning communication channel. Thus, it is highly recommended to be careful when writing the necessary code.

= Swt =

Thus example demonstrates a simple ui that may be useful for debugging. There are two versions of this ui available. One is written using SWT (the toolkit used by eclipse) and one is written using the LCDUI of the Java micro-edition. The SWT ui has been tested (often) on Windows Mobile and Windows PDAs. Furthermore, there should be versions for other operating systems such as Linux and OSX. The LCDUI has been tested on a Nokia 6630 and it runs well in the J2ME emulator. The example itself uses the SWT ui to be usable directly. Since SWT requires native libraries, it is neccessary to add the corresponding "dlls" to the path. This can be done by the "-D" JVM option that sets the "java.library.path" variable. On a Windows Mobile PDA with J9, it is necessary to put the "dlls" in the "Windows" directory. Let me know if you find a better solution. 

When starting the ui, you should open the system browser. The system browser will display the available devices, including their ids, names, plugins and well-known services. If a device is equipped with a service registry, you can select it to open the service browser (via right-click popup menu or the "view" menu). The service browser enables you to create queries (with local/remote scope, name and service type). To create a query click on the green "+" next to the query pulldown. Specify the parameters and click on the "checker" to store it. Now you can select the query and click on the "run" button. This will fill the combobox at the bottom with the result. The combobox in the middle enables you to construct a method call which can be executed on a result using the associated "run" button. To create an invocation, click on the "plus" button, specify the method name an parameter and click on the "checker" to store it. Now you can run a query and then select an item from the result list to "run" a selected invocation.

= Emulator =

The emulator example demonstrates a special transceiver plugin. This transceiver plugin enables you to emulate a particular network topology. When using the other IP-based plugins on a local machine, BASE will always detect all devices. If this is not desired, you can use the Emulator transceiver as a replacement. This transceiver uses a scenario file to restrict the visibility. To do this, you need to explicity define the IP/port of each device and their connections. The scenario file contains a more detailed description of that. Note that it is also possible to run two instances of one simulation on seperate machines. When the emulator starts, it will first determine its local ip address and then it will sequentially try to bind to a port of the devices specified for that machine. That means if you are starting the first process, it will use the first device for this machine, if you start the second, it will use the second and so on. If you kill one of the process, lets say the first, the next process will bind to the first again. The emulator example simply uses the rmi example in an emulated topology. The current scenario file defines 4 devices that are connected in a ring. So if you start it completely (with four instances of BASE), each device will only see two services at a time. In order to test multihop routing, you can simply uncomment the line that would add the proactive routing plugin. If you do that, you will see that each device will now be able to connect to three services (from the three remote devices). 

= Midlet =

The midlet example demonstrates the use of BASE within a Midlet. The code simply references the main projects (core, plugin and bluetooth plugin) as well as the midlet gui project (lcdui). The configuration of BASE can be done in the start method of the midlet. Simply load the gui, load the broker, load the plugins and finally, show the gui. Once the gui is loaded, you can switch a "console" view on and off. To do this, press the right "menu" button and select "console". You can scroll through the contents of the console using the cursor keys. In addition to the console, you may also turn on another view such as the launcher (which shows all open views) or the system browser (which shows all connected systems). The tree in the system browser can be navigated using the cursor keys. Similarly, the elements in the launcher can be navigated using the cursor keys and activated using the "action" key.