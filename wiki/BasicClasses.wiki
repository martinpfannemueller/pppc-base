#summary A brief discussion of the main classes of BASE.

= Introduction =

Probably the main feature of BASE is its ability to flexibly compose communication stacks from plugins. To do this it relies on a "small" core that needs to be present on all devices. This core can be extended with plugins that can wrap communication technologies (ip, bluetooth, ir), protocols (serialization, compression, encryption) and abstractions (i.e. streams, rmi, etc.). Apart from that, BASE provides a "simple" API that can be used to implement applications or futher middleware (e.g. the PCOM component system). Since BASE is not only intended for services (i.e. it can also be used for other abstractions), the service registry is not a core part of the system. Instead the core defines an interface for building high-level services such as registries or component container that can be installed optionally. This design has an impact on what is provided by the core and what needs to be provided via extensions. Obviously the general idea is to keep the core minimal.

= Addressing =

*Addressing devices* - In order to uniquely identify a device (despite the fact that it may have multiple/changing physical addresses), BASE introduces a unique (logical) identifier called SystemID. At the present time the system id is simply a long value. This value can be fixed to a certain value by setting a system property at startup. If this property is not available, BASE will simply generate a random id. Given that we have been experminting with a rather low number of devices, this has never been a problem - so far. 

*Addressing objects* - In order to uniquely identify an object on a particular device, BASE provides an ObjectID. The object id is simply a large number that is incremented every time an object id is created. Intuitively, this approach only works for local objects (since there is no global counter). Obviously, it is possible to construct a globally unique object identifier by combining an ObjectID with a SystemID. In BASE, this is called a ReferenceID and it is frequently used to identify the source and the target of an interaction. The value domain of ObjectIDs is fragmented into two different areas. The space above 0 is called "well-known" and object IDs with positive values can be generated manually (by an appropriate constructor). The space below 0 is completely controlled by the system and thus, it is not guaranteed that an object ID will be the same during two consequtive executions.

= Interaction =

*Finding objects* - Given the randomness of the identifiers (for both devices and objects) as well as the extensibility of the core, an immediate question is how BASE can be used to determine what is out there. For this, the core utilizes two registries. The first registry is called the *!ObjectRegistry*. This registry is responsible for managing the local objects. A local object that shall be accessible through BASE must impement the *IInvocationHandler* interface that accepts incoming invocations (i.e. interactions). Local objects can either be registered with a well-known or an auto-generated id. The way how auto-generated ids are distributed is not defined by the core (but this can be done, for example, with the service registry extension). However, well-known ids are distributed proactively. This enables remote devices to reason about the capabilities of the local device. Of course, for this to work, there needs to be a common agreement on the usage of these ids. Thus, it is not wise to reuse the same well-known id for unrelated types of invocation handlers. In order to distribute the well-known ids of the local system, the *!ObjectRegistry* updates the so-called *!DeviceDescription*. This description is stored within the *!DeviceRegistry*. Besides from the well-known objects and the SystemID of the device, it contains other (but small amounts) of data that are generally useful, e.g. a human readable device name and an integer that denotes a device type. These things are used by the graphical user interface to represent the device. In addition to the *!DeviceDescription* of the local device, the *!DeviceRegistry* also holds the descriptions of all devices that are available remotely. This enables an application or a service to retrieve the current list of available devices and their associated "well-known" objects. Of course, there is also a notification interface to keep track of changes in device availability. With these mechanisms, the *!DeviceRegistry* enables the development of bootstraping services for objects attached to auto-generated ids. Although, it is theoretically possible to solely rely on well-known ids, this is typically not desirable since they must be distributed continously.

*Interacting with objects* - From an application programmer's point of view, local and remote interaction is hidden by the core class of BASE - the so-called *!InvocationBroker*. This class mediates so called *Invocations* which represent an interaction. In most cases, however, an application object will not directly interact with the broker. Instead, it will use a proxy that can be generated statically from a Java interface using an Eclipse plugin. The proxy then takes care of creating the invocation object and returning the result. In order for this to work, the proxy needs to be bound to a specific target object on a target system. If the target is located on the same system as the caller, the invocation broker will forward the call locally. If the target is on a remote system, the invocation broker passes the invocation to the plugin manager which will take care of managing the remote communication.

= Communication =

*Communication* - As indicated previously, communication in BASE is managed by the *!PluginManager*. The BASE plugin model supports the implementation of several different types of plugins. At the lowest layer, transceiver plugins to provide connection-oriented 1-to-1 communication and packet-oriented 1-to-many communication. Above the transceivers, modifier plugins can provide additional protocols such as routing, object serialization, encryption, compression, etc. At the top, semantic plugins provide different communication semantics (e.g. streams, rmi, etc.). The plugin manager takes care of automatically composing communication stacks for invocations that shall be transmitted and received. The stack composition can be controlled by applications by attaching an appropriate *NFCollection* to the invocation. This class enables a developer to specify, for example, that an invocation must be transmitted via Bluetooth or that it should be encrypted. To do this, a developer specifies different values for *NFDimensions* and attaches them to the *NFCollection*. When composing a communication stack, the plugin manager inteprets these dimensions for each layer and decides whether a stack is suitable. To do this, the plugin manager must consider not only the locally installed plugins but also the plugins that are available on the target device. To be able to reason about remote plugins, each plugin is equipped with a *!PluginDescription*. The plugin description denotes (at least) the layer that is implemented by the plugin by means of the *extension* attribute. Furthermore, it defines compatibility with other plugins by means of the *ability* attribute. Plugins that have the same ability are considered to be compatible. Finally, a plugin description can contain a number of plugin-specific properties that are used to enable communication (e.g. the IP address and port number for an IP-based transceiver). When composing a stack, BASE will automatically supply the calling plugin with the plugin description of the remote device. So the calling plugin can read the remote description to initiate the communication (e.g. by opening a TCP connection to the target address and port). For this to work, all plugin descriptions of devices in the vicinity need to be available locally and BASE uses the previously introduced *!DeviceRegistry* to store them. The continuous distribution of plugin descriptions is one of the main tasks of another class of plugins, the so-called discovery plugins.

*Discovery* - In order to support the spontaneous interaction of device, BASE needs to continously distribute the two types of descriptions (i.e. the *!PluginDescriptions* and the *!DeviceDescription*). Since there are multiple ways of doing this, BASE abstracts from the distribution process by means of discovery plugins. At the present time, we usually rely on a proactive discovery plugin that simply broadcast the descriptions every 3 seconds and that removes them, if a broadcast has not been heard for more than 10 seconds. However, more complicated strategies can be implemented easily.

= Utilities =

*Utilities* - The BASE core provides a number of utilities that you might want to reuse within applications in order to keep your code small. The *event* package defines a generic listener interface that is used consistently in BASE. The listener interface takes as an input a generic event. An event contains a type that is used to dispatch different events. It also contains a source object and it may contain a data object. Note that the event type is interpreted as bitmask. So if you define an event type with the id 3, this means that you are actually defining an event of type 2 and 1. In addition to this rather simple interface, the event package also contains a generic data structure for managing listeners and firing events. This data structure is called *!ListenerBundle*. Similar to events, BASE also provides a package for threading called *operation*. It defines an *IOperation* interface that is similar to java.system.Runnable. Furthermore, it provides an implementation of a thread pool. The central thread pool of BASE is created by the *!InvocationBroker* upon startup and it makes sense to use this pool for your applications as well.